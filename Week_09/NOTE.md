学习笔记

## 高级动态规划

* 递归：函数自己调用自己
* 分治：分而治之
* 动态规划：最优子结构、重复子问题、分治
* 关键点：动态规划、递归、分治没有本质上的区别（关键看有无最优子结构）

## 常见的DP题目和状态转移方程

* 爬楼梯：f(n) = f(n-1) + f(n-2), f(1) = 1, f(0) = 0

* 不同路径：f(x,y) = f(x-1,y) + f(x, y-1)

* 打家劫舍：
  dp[i]状态的定义：max $ of robbing A[0 -> i]

  dp[i] = max(dp[i - 2]] + nums[i], dp[i - 1])
  dp(i,0)状态的定义：max $ of robbing A[0 -> i] 且没偷nums[i]

  dp(i,1)状态定义：max $ of robbing A[0 -> i] 且偷了num[i]

  dp(i,0) = max(dp[i-1][0], dp[i-1][1])

  dp[i][1] = dp[i-1][0] + nums[i]

* 最小路径和
  dp[i][j] 状态的定义：minPath(A[1->i][1->j])

  dp[i][j] = min(dp[i-1][j], dp[i][j-1] + A[i][j])

* 股票买卖
  dp[i][k][0 or 1] (0 <= i <= n-1, 1 <= k <= K)

  * i为天s数
  * k 为最多交易次数
  * [0,1]为是否持有股票dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) max( 选择 rest , 选择 sell )
    解释:今天我没有持有股票，有两种可能:
    - 我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有; - 我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。
    dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) max( 选择 rest , 选择 buy )
    解释:今天我持有着股票，有两种可能:
    - 我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票; - 我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。

  

  

## 字符串

遍历字符串、字符串比较

字符串相关算法：

* Atoi

* Anagram异位词问题

* Palindrome回文串问题

* 最长子串、子序列

* 字符串匹配算法

  













